"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[3640],{89992:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var r=a(17624),s=a(4552);const o={title:"#[ink::contract]",slug:"/macros-attributes/contract",hide_title:!0},l=void 0,t={id:"macros-attributes/contract",title:"#[ink::contract]",description:"Esta macro es el punto de entrada para escribir smart contracts ink!.",source:"@site/i18n/es/docusaurus-plugin-content-docs/version-5.x/macros-attributes/contract.md",sourceDirName:"macros-attributes",slug:"/macros-attributes/contract",permalink:"/es/5.x/macros-attributes/contract",draft:!1,unlisted:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-5.x/macros-attributes/contract.md",tags:[],version:"5.x",frontMatter:{title:"#[ink::contract]",slug:"/macros-attributes/contract",hide_title:!0},sidebar:"reference",previous:{title:"Introducci\xf3n",permalink:"/es/5.x/macros-attributes"},next:{title:"#[ink(anonymous)]",permalink:"/es/5.x/macros-attributes/anonymous"}},i={},c=[{value:"Descripci\xf3n",id:"descripci\xf3n",level:2},{value:"Uso",id:"uso",level:2},{value:"Argumentos del Header",id:"argumentos-del-header",level:3},{value:"<code>compile_as_dependency: bool</code>",id:"compile_as_dependency-bool",level:3},{value:"<code>env: impl Environment</code>",id:"env-impl-environment",level:3},{value:"An\xe1lisis",id:"an\xe1lisis",level:2},{value:"Interactuando con el Ejecutor del Contrato",id:"interactuando-con-el-ejecutor-del-contrato",level:2},{value:"Eventos",id:"eventos",level:2},{value:"Ejemplo: Flipper",id:"ejemplo-flipper",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.M)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("img",{src:"/img/title/text/contract.svg",className:"titlePic"}),"\n",(0,r.jsx)(n.p,{children:"Esta macro es el punto de entrada para escribir smart contracts ink!."}),"\n",(0,r.jsxs)(n.p,{children:["Si eres un principiante aprendiendo ink! Le recomendamos que consulte nuestro amplio\n",(0,r.jsx)(n.a,{href:"https://docs.substrate.io/tutorials/smart-contracts/",children:"workshop de ink! "}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"descripci\xf3n",children:"Descripci\xf3n"}),"\n",(0,r.jsx)(n.p,{children:"La macro analiza el c\xf3digo del smart contract proporcionado y genera el c\xf3digo adecuado."}),"\n",(0,r.jsx)(n.h2,{id:"uso",children:"Uso"}),"\n",(0,r.jsx)(n.h3,{id:"argumentos-del-header",children:"Argumentos del Header"}),"\n",(0,r.jsxs)(n.p,{children:["A la macro ",(0,r.jsx)(n.code,{children:"#[ink::contract]"})," se le puede proporcionar argumentos header adicionales separados por coma:"]}),"\n",(0,r.jsx)(n.h3,{id:"compile_as_dependency-bool",children:(0,r.jsx)(n.code,{children:"compile_as_dependency: bool"})}),"\n",(0,r.jsxs)(n.p,{children:["Le dice al generador de c\xf3digo de ink! que  ",(0,r.jsx)(n.strong,{children:"siempre"})," o ",(0,r.jsx)(n.strong,{children:"nunca"}),"\ncompile smart contract como si fuese utilizado como dependencia de otro smart contract de ink!"]}),"\n",(0,r.jsx)(n.p,{children:"Normalmente este flag solo es \xfatil para desarrolladores de ink! que\nquieran inspeccionar el la generaci\xf3n de c\xf3digo de los ink! smart contracts.\nEl autor no tiene conocimiento de ning\xfan caso de uso pr\xe1ctico particular para los usuarios que hagan uso de este flag,\npero se alienta a los redactores de contratos a refutar esto."}),"\n",(0,r.jsxs)(n.p,{children:["Date cuenta que se recomienda hacer uso de las feature built-in crate.\n",(0,r.jsx)(n.code,{children:"ink-as-dependency"})," para marcar las dependencias del smart contract\n",(0,r.jsx)(n.code,{children:"Cargo.toml"})," como dependencia actual de ink!."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[ink::contract(compile_as_dependency = true)]\nmod my_contract {\n    #[ink(storage)]\n    pub struct MyStorage;\n    \n    impl MyStorage {\n        #[ink(constructor)]\n        pub fn construct() -> Self { MyStorage {} }\n        \n        #[ink(message)]\n        pub fn message(&self) {}\n    }\n    // ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default value:"})," Depende de la propagaci\xf3n de la feature del crate de ",(0,r.jsx)(n.code,{children:"Cargo.toml"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"env-impl-environment",children:(0,r.jsx)(n.code,{children:"env: impl Environment"})}),"\n",(0,r.jsxs)(n.p,{children:["Le dice al generador de c\xf3digo ink! que entorno utilizar para el ink! smart contract.\nEl entorno debe implementar el trait ",(0,r.jsx)(n.code,{children:"Environment"})," (definido en ",(0,r.jsx)(n.code,{children:"ink_env"}),") y proporciona\ntodas las necesarias definiciones de tipo fundamentales para ",(0,r.jsx)(n.code,{children:"Balance"}),", ",(0,r.jsx)(n.code,{children:"AccountId"})," etc."]}),"\n",(0,r.jsxs)(n.p,{children:["Cuando utilizamos la implementaci\xf3n personalizada de  ",(0,r.jsx)(n.code,{children:"Environment"})," para smart contract todos los tipos\nque se exponen en el smart contract ink! y los tipos reflejados utilizados en el runtima\ndeben ser alineados con respecto a la codificaci\xf3n y semanticos SCALE."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Ejemplo de Uso:"})}),"\n",(0,r.jsxs)(n.p,{children:["Dada la implementaci\xf3n personalizada ",(0,r.jsx)(n.code,{children:"Environment"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub struct MyEnvironment;\n\nimpl ink::env::Environment for MyEnvironment {\n    const MAX_EVENT_TOPICS: usize = 3;\n    \n    type AccountId = u64;\n    type Balance = u128;\n    type Hash = [u8; 32];\n    type Timestamp = u64;\n    type BlockNumber = u32;\n    type ChainExtension = ::ink::env::NoChainExtension;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Un usuario puede implementar su smart contract ink! utilizando la implementaci\xf3n personalizada\n",(0,r.jsx)(n.code,{children:"Environment"})," de arriba, como se demuestra a continuaci\xf3n:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[ink::contract(env = MyEnvironment)]\nmod my_contract {\n    pub struct MyEnvironment;\n   \n    impl ink::env::Environment for MyEnvironment {\n        const MAX_EVENT_TOPICS: usize = 3;\n        type AccountId = u64;\n        type Balance = u128;\n        type Hash = [u8; 32];\n        type Timestamp = u64;\n        type BlockNumber = u32;\n        type ChainExtension = ::ink::env::NoChainExtension;\n    }\n    \n    #[ink(storage)]\n    pub struct MyStorage;\n    \n    impl MyStorage {\n        #[ink(constructor)]\n        pub fn construct() -> Self { MyStorage {} }\n        \n        #[ink(message)]\n        pub fn message(&self) {}\n    }\n    // ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Valor por defecto:"})," ",(0,r.jsx)(n.code,{children:"DefaultEnvironment"})," definido en el crate ",(0,r.jsx)(n.code,{children:"ink_env"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"an\xe1lisis",children:"An\xe1lisis"}),"\n",(0,r.jsxs)(n.p,{children:["La macro ",(0,r.jsx)(n.code,{children:"#[ink::contract]"})," macro analiza completamente el smart contract\ndel input contra argumentos y estructuras no v\xe1lidas."]}),"\n",(0,r.jsx)(n.p,{children:"Algunas reglas de ejemplo incluyen pero no se limitan a:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Debe existir exactamente una estructura ",(0,r.jsx)(n.code,{children:"#[ink(storage)]"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Esta estructura define el dise\xf1o del storage sobre el que el smart contract de ink! opera.\nEl usuario puede utilizar una variedad de facilidades built-in, combinandolas de diversas maneras\no incluso proporcionando su propia implementacions de las estructuras de datos del storage."}),"\n",(0,r.jsxs)(n.p,{children:["Para m\xe1s informaci\xf3n visita la documentaci\xf3n del crate ",(0,r.jsx)(n.code,{children:"ink_storage"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Ejemplo:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[ink::contract]\nmod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        #[ink(constructor)]\n        pub fn construct() -> Self { Flipper { value: false } }\n\n        #[ink(message)]\n        pub fn message(&self) {}\n    }\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Tiene que haber al menos un ",(0,r.jsx)(n.code,{children:"#[ink(constructor)]"})," m\xe9todo definido."]}),"\n",(0,r.jsxs)(n.p,{children:["Los m\xe9todos marcados con ",(0,r.jsx)(n.code,{children:"#[ink(constructor)]"})," son especiales porque sonson despachables\ntras la instanciaci\xf3n del contrato. Un contrato puede definir m\xfaltiples constructores\nde este tipo que permitan a los usuarios del contrato instanciar un contrato de m\xfaltiples maneras diferentes."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Ejemplo:"})}),"\n",(0,r.jsxs)(n.p,{children:["Dada la definici\xf3n del contrato ",(0,r.jsx)(n.code,{children:"Flipper"})," de arriba, a\xf1adimos un ",(0,r.jsx)(n.code,{children:"#[ink(constructor)]"}),"\ncomo puedes ver:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[ink::contract]\nmod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        #[ink(constructor)]\n        pub fn new(initial_value: bool) -> Self {\n            Flipper { value: false }\n        }\n\n        #[ink(message)]\n        pub fn message(&self) {}\n    }\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Tiene que haber al menos un ",(0,r.jsx)(n.code,{children:"#[ink(message)]"})," m\xe9todo definido."]}),"\n",(0,r.jsxs)(n.p,{children:["Los m\xe9todos marcados con ",(0,r.jsx)(n.code,{children:"#[ink(message)]"})," son especiales porque sonson despachables\ntras la instanciaci\xf3n del contrato. El conjunto de mensajes ink! definidos por un smart contract\nink! define su superficie API con la que los usuarios pueden interactuar."]}),"\n",(0,r.jsx)(n.p,{children:"Un ink! smart contract puede tener multiples mensajes ink! definidos."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Note:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Un mensaje ink! con un receptor ",(0,r.jsx)(n.code,{children:"&self"})," solo puede leer el estado mientras que un mensaje ink!\ncon un receptor ",(0,r.jsx)(n.code,{children:"&mut self"})," puede mutar el storage del contrato."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Ejemplo:"})}),"\n",(0,r.jsxs)(n.p,{children:["Dada la definici\xf3n del contrato ",(0,r.jsx)(n.code,{children:"Flipper"})," de arriba, a\xf1adimos algunas definiciones ",(0,r.jsx)(n.code,{children:"#[ink(message)]"}),"\ncomo puedes ver:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[ink::contract]\nmod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        #[ink(constructor)]\n        pub fn new(initial_value: bool) -> Self {\n            Flipper { value: false }\n        }\n\n        /// Flips the current value.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        /// Returns the current value.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Payable Messages:"})}),"\n",(0,r.jsxs)(n.p,{children:["Un mensaje ink! por defecto rechazara llamadas que adicionalmente financial el smart contract.\nAutores del smart contract de ink pueden hacer que el mensaje de ink! sea payable a\xf1adiendole\nla marca ",(0,r.jsx)(n.code,{children:"payable"}),". Un ejemplo a continuaci\xf3n:"]}),"\n",(0,r.jsx)(n.p,{children:"Date cuenta que los constructores ink! son implicitamente siempre payables y por lo tanto\nno puden marcarse como tal."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[ink::contract]\nmod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        #[ink(constructor)]\n        pub fn new(initial_value: bool) -> Self {\n            Flipper { value: false }\n        }\n\n        /// Voltea el valor actual \n        #[ink(message)]\n        #[ink(payable)] // Puedes especificar payable out-of-line.\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        /// Devuelve el valor actual\n        #[ink(message, payable)] // ...o especificar payable inline.\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Controlar el selector de mensajes:"})}),"\n",(0,r.jsx)(n.p,{children:"Cada mensaje y constructor de ink! tiene un \xfanico selector con el que cada mensaje\no constructor puede ser unicamente identificado dentro del smart contract de ink!.\nEstos selectores se utilizan principalmente para conducir el dispatch del contrato al llamarlo."}),"\n",(0,r.jsxs)(n.p,{children:["El autor de un smart contract ink! puede controlar el selector de un mensaje o contructor ink!\nutilizando el flag ",(0,r.jsx)(n.code,{children:"selector"})," flag. A continuaci\xf3n de muestra un ejemplo:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[ink::contract]\nmod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        #[ink(constructor)]\n        #[ink(selector = "0xDEADBEEF")] // Funciona en los constructores tambien.\n        pub fn new(initial_value: bool) -> Self {\n            Flipper { value: false }\n        }\n\n        /// Voltea el valor actual.\n        #[ink(message)]\n        #[ink(selector = "0xCAFEBABE")] //Puedes especificar el selector out-of-line.\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n       \n        /// Devuelve el valor actual.\n        #[ink(message, selector = "0xFEEDBEEF")] // ...o puedes especificar el selector inline.\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"interactuando-con-el-ejecutor-del-contrato",children:"Interactuando con el Ejecutor del Contrato"}),"\n",(0,r.jsxs)(n.p,{children:["El crate ",(0,r.jsx)(n.code,{children:"ink_env"})," provee facilidades para interactuar con el ejecutor del contrato\nque conecta el smart contract ink! con el mundo exterior."]}),"\n",(0,r.jsx)(n.p,{children:"Por ejemplo es posible consultar la persona que llama en la llamada actual a trav\xe9s de:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use ink_env;\nink::env::test::run_test::<ink::env::DefaultEnvironment, _>(|_| {\n    let caller = ink::env::caller::<ink::env::DefaultEnvironment>();\n    let _caller = caller;\n    Ok(())\n}).unwrap();\n"})}),"\n",(0,r.jsx)(n.p,{children:"Sin embargo, ink! provee una manera mucho m\xe1s simple de interactuar con el ejecutor\ndel contrato a trav\xe9s de su entorno de acceso. Un ejemplo a continuaci\xf3n:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[ink::contract]\nmod greeter {\n    #[ink(storage)]\n    pub struct Greeter;\n\n    impl Greeter {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            let caller = Self::env().caller();\n            let message = format!("thanks for instantiation {:?}", caller);\n            ink::env::debug_println(&message);\n            Greeter {}\n        }\n\n        #[ink(message, payable)]\n        pub fn fund(&mut self) {\n            let caller = self.env().caller();\n            let value = self.env().transferred_balance();\n            let message = format!("thanks for the funding of {:?} from {:?}", value, caller);\n            ink::env::debug_println(&message);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"eventos",children:"Eventos"}),"\n",(0,r.jsx)(n.p,{children:"Un smart contract ink! puede definir eventos que puedan emitir durante la ejecuci\xf3n del contrato.\nEmitir eventos puede ser utilizado por herramientas de terceras partes para consultar informaci\xf3n\nacerca de la ejecuci\xf3n y el estado del contrato."}),"\n",(0,r.jsxs)(n.p,{children:["El siguiente ejemplo de un contrato ink! muestra como un evento ",(0,r.jsx)(n.code,{children:"Transferred"})," es definido y\nemitido en el ",(0,r.jsx)(n.code,{children:"#[ink(constructor)]"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:" #[ink::contract]\n mod erc20 {\n     /// Define un evento que es emitido cada vez que el valor es transferido.\n     #[ink(event)]\n     pub struct Transferred {\n         from: Option<AccountId>,\n         to: Option<AccountId>,\n         value: Balance,\n     }\n\n     #[ink(storage)]\n     pub struct Erc20 {\n         total_supply: Balance,\n         // m\xe1s campos ...\n     }\n\n     impl Erc20 {\n         #[ink(constructor)]\n         pub fn new(initial_supply: Balance) -> Self {\n             let caller = Self::env().caller();\n             Self::env().emit_event(Transferred {\n                 from: None,\n                 to: Some(caller),\n                 value: initial_supply,\n             });\n             Self { total_supply: initial_supply }\n         }\n\n         #[ink(message)]\n         pub fn total_supply(&self) -> Balance {\n             self.total_supply\n         }\n     }\n }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"ejemplo-flipper",children:"Ejemplo: Flipper"}),"\n",(0,r.jsx)(n.p,{children:'El c\xf3digo a continuaci\xf3n muestra la implementaci\xf3n completa del smart contract ink! Flipper.\nPara nosotros actua como el "Hello, World!" de los smart contracts ink! porque\nes minimo pero a la vez proporciona m\xe1s o menos una funcionalidad \xfatil.'}),"\n",(0,r.jsxs)(n.p,{children:["Controla un simple valor  ",(0,r.jsx)(n.code,{children:"bool"})," que puede ser tanto ",(0,r.jsx)(n.code,{children:"false"})," como ",(0,r.jsx)(n.code,{children:"true"}),"\ny permite al usuario voltear el valor utilizando el mensaje ",(0,r.jsx)(n.code,{children:"Flipper::flip"}),"\no recuperar el valor actual utilizando ",(0,r.jsx)(n.code,{children:"Flipper::get"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[ink::contract]\npub mod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Crea un nuevo smart contract flipper inicializando el valor dado\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Voltea el valor actual del booleano de Flipper.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        /// Devuelve el valor actual del boolean de Flipper.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.M)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},4552:(e,n,a)=>{a.d(n,{I:()=>t,M:()=>l});var r=a(11504);const s={},o=r.createContext(s);function l(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);