"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[4860],{27484:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>d,metadata:()=>c,toc:()=>l});var n=r(17624),t=r(4552);const d={title:"Formato de la Metadata",slug:"/datastructures/storage-in-metadata",hide_title:!0},o="Formato de la Metadata",c={id:"datastructures/storage-in-metadata",title:"Formato de la Metadata",description:"La estructura del storage de un contrato se ve reflejada dentro de la metadata. Permite a herramientas de terceros trabajar con un contrato y poder mejorar la comprensi\xf3n de la estructura del storage de cualquier contrato.",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/datastructures/storage-in-metadata.md",sourceDirName:"datastructures",slug:"/datastructures/storage-in-metadata",permalink:"/es/datastructures/storage-in-metadata",draft:!1,unlisted:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/docs/datastructures/storage-in-metadata.md",tags:[],version:"current",frontMatter:{title:"Formato de la Metadata",slug:"/datastructures/storage-in-metadata",hide_title:!0},sidebar:"reference",previous:{title:"Estructuras de Datos Personalizadas",permalink:"/es/datastructures/custom-datastructure"},next:{title:"Introducci\xf3n",permalink:"/es/frontend/overview"}},s={},l=[{value:"C\xe1lculo de la key del storage para valores de un ink! <code>Mapping</code>",id:"c\xe1lculo-de-la-key-del-storage-para-valores-de-un-ink-mapping",level:2},{value:"Accediendo a elementos del storage con la llamada de runtime <code>contractsApi</code>",id:"accediendo-a-elementos-del-storage-con-la-llamada-de-runtime-contractsapi",level:2},{value:"Accediendo a elementos del storage con la llamada RPC <code>childState</code>",id:"accediendo-a-elementos-del-storage-con-la-llamada-rpc-childstate",level:2},{value:"Encontrando el ID del child trie de los contratos",id:"encontrando-el-id-del-child-trie-de-los-contratos",level:3},{value:"Calcular el <code>PrefixedStorageKey</code> del ID del child trie",id:"calcular-el-prefixedstoragekey-del-id-del-child-trie",level:3},{value:"Calcular la key del storage usando hasheo transparente",id:"calcular-la-key-del-storage-usando-hasheo-transparente",level:3},{value:"Ejemplo completo",id:"ejemplo-completo",level:3}];function i(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.M)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)("img",{src:"/img/title/storage.svg",className:"titlePic"}),"\n",(0,n.jsx)(a.h1,{id:"formato-de-la-metadata",children:"Formato de la Metadata"}),"\n",(0,n.jsx)(a.p,{children:"La estructura del storage de un contrato se ve reflejada dentro de la metadata. Permite a herramientas de terceros trabajar con un contrato y poder mejorar la comprensi\xf3n de la estructura del storage de cualquier contrato."}),"\n",(0,n.jsx)(a.p,{children:"Dado un contrato con el siguiente storage:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-rust",children:"#[ink(storage)]\r\npub struct MyContract {\r\n    balance: Balance,\r\n    block: BlockNumber,\r\n    lazy: Lazy<bool>,\r\n}\n"})}),"\n",(0,n.jsx)(a.p,{children:"El storage se ver\xe1 reflejado dentro de la metadata de la siguiente manera:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-json",children:'"root": {\r\n  "layout": {\r\n    "struct": {\r\n      "fields": [\r\n        {\r\n          "layout": {\r\n            "leaf": {\r\n              "key": "0x00000000",\r\n              "ty": 0\r\n            }\r\n          },\r\n          "name": "balance"\r\n        },\r\n        {\r\n          "layout": {\r\n            "leaf": {\r\n              "key": "0x00000000",\r\n              "ty": 1\r\n            }\r\n          },\r\n          "name": "block"\r\n        },\r\n        {\r\n          "layout": {\r\n            "root": {\r\n              "layout": {\r\n                "leaf": {\r\n                  "key": "0xb1f4904e",\r\n                  "ty": 2\r\n                }\r\n              },\r\n              "root_key": "0xb1f4904e"\r\n            }\r\n          },\r\n          "name": "lazy"\r\n        }\r\n      ],\r\n      "name": "MyContract"\r\n    }\r\n  },\r\n  "root_key": "0x00000000"\r\n}\n'})}),"\n",(0,n.jsxs)(a.p,{children:["Observamos que la estructura del storage se representa con un \xe1rbol, en el cual los valores tangibles de storage terminan dentro de una ",(0,n.jsx)(a.code,{children:"leaf"}),". A causa de la codificaci\xf3n ",(0,n.jsx)(a.a,{href:"https://docs.rs/ink_storage_traits/4.0.0/ink_storage_traits/trait.Packed.html",children:(0,n.jsx)(a.code,{children:"Packed"})}),", las hojas pueden compartir la misma key del storage, y para acceder a ellas es necesario buscar y decodificar toda la celda que corresponde a esa key."]}),"\n",(0,n.jsxs)(a.p,{children:["Una ",(0,n.jsx)(a.code,{children:"root_key"})," est\xe1 destinada ya sea a ser utilizada para acceder directamente a un campo de storage ",(0,n.jsx)(a.code,{children:"Packed"})," o para servir como la key base para calcular las keys reales necesarias para acceder a los valores de los campos non-",(0,n.jsx)(a.code,{children:"Packed"})," (por ejemplo ",(0,n.jsx)(a.code,{children:"Mapping"}),"s)"]}),"\n",(0,n.jsxs)(a.h2,{id:"c\xe1lculo-de-la-key-del-storage-para-valores-de-un-ink-mapping",children:["C\xe1lculo de la key del storage para valores de un ink! ",(0,n.jsx)(a.code,{children:"Mapping"})]}),"\n",(0,n.jsxs)(a.p,{children:["Las keys base del storage siempre tienen un tama\xf1o de 4 bytes. Sin embargo, la API de storage del pallet ",(0,n.jsx)(a.code,{children:"contracts"})," soporta keys de longitudes arbitrarias. Para acceder a un valor de un mapping, la key del storage de dicho valor se calcula en tiempo de ejecuci\xf3n."]}),"\n",(0,n.jsxs)(a.p,{children:["La f\xf3rmula para calcular la key base de un storage ",(0,n.jsx)(a.code,{children:"S"})," utilizada para acceder a un valor de mapping que corresponde a la key ",(0,n.jsx)(a.code,{children:"K"})," para un mapping con una key base ",(0,n.jsx)(a.code,{children:"B"})," puede expresarse de la siguiente manera:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{children:"S = scale::encode(B) + scale::encode(K)\n"})}),"\n",(0,n.jsxs)(a.p,{children:["En donde la key base ",(0,n.jsx)(a.code,{children:"B"})," es la ",(0,n.jsx)(a.code,{children:"root_key"})," (de tipo ",(0,n.jsx)(a.code,{children:"u32"}),") encontrada en la metadata del contrato."]}),"\n",(0,n.jsx)(a.p,{children:"En otras palabras, codificar con SCALE la key base (root) del mapping y concatenarla con la key codificada con SCALE del valor de mapping para obtener la key del storage real utilizada para acceder al valor mapeado."}),"\n",(0,n.jsx)(a.p,{children:"Dado el siguiente storage de un contrato, que mapea cuentas a un balance:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-rust",children:"#[ink(storage)]\r\npub struct Contract {\r\n    roles: Mapping<AccountId, Balance, ManualKey<0x12345678>>,\r\n}\n"})}),"\n",(0,n.jsxs)(a.p,{children:["Ahora supongamos que estamos interesados en encontrar el balance para la cuenta ",(0,n.jsx)(a.code,{children:"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY"}),". La key del storage se calcula as\xed:"]}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsxs)(a.li,{children:["Codificar en SCALE la key base del mapping (",(0,n.jsx)(a.code,{children:"0x12345678u32"}),"), da como resultado ",(0,n.jsx)(a.code,{children:"0x78563412"})]}),"\n",(0,n.jsxs)(a.li,{children:["Codificar en SCALE la ",(0,n.jsx)(a.code,{children:"AccountId"}),", que ser\xe1\r\n",(0,n.jsx)(a.code,{children:"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d"}),".\r\nTener en cuenta que primero ser\xe1 necesario convertir el SS58 en una ",(0,n.jsx)(a.code,{children:"AccountId32"}),"."]}),"\n",(0,n.jsxs)(a.li,{children:["Concatenar estas dos dar\xe1 como resultado la key\r\n",(0,n.jsx)(a.code,{children:"0x78563412d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d"}),"."]}),"\n"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-rust",children:'let account_id = "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY";\r\nlet account: AccountId32 = Ss58Codec::from_string(account_id).unwrap();\r\nlet storage_key = &(0x12345678u32, account).encode();\r\nprintln!("0x{}", hex::encode(storage_key));\r\n// 0x78563412d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\n'})}),"\n",(0,n.jsxs)(a.h2,{id:"accediendo-a-elementos-del-storage-con-la-llamada-de-runtime-contractsapi",children:["Accediendo a elementos del storage con la llamada de runtime ",(0,n.jsx)(a.code,{children:"contractsApi"})]}),"\n",(0,n.jsxs)(a.p,{children:["Hay dos maneras de consultar los campos del storage de los smart contracts desde afuera de un contrato. Ambos m\xe9todos son accesibles a trav\xe9s de la UI web de ",(0,n.jsx)(a.a,{href:"https://polkadot.js.org/apps/",children:(0,n.jsx)(a.code,{children:"polkadot-js"})}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["La manera directa de consultar el storage de contratos es a trav\xe9s de una llamada ",(0,n.jsx)(a.a,{href:"https://polkadot.js.org/apps/#/runtime",children:(0,n.jsx)(a.code,{children:"runtime API"})}),", utilizando el endpoint ",(0,n.jsx)(a.code,{children:"contractsApi"})," provisto por el contracts pallet. El endpoint provee un m\xe9todo ",(0,n.jsx)(a.code,{children:"getStorage"}),", que s\xf3lo espera una direcci\xf3n de contrato y una key del storage como argumentos."]}),"\n",(0,n.jsxs)(a.p,{children:["Por ejemplo, para acceder al struct del root storage correspondiente a la key ",(0,n.jsx)(a.code,{children:"0x00000000"})," de un contrato, s\xf3lo especifique la direcci\xf3n el contrato y la key del storage ",(0,n.jsx)(a.code,{children:"0x00000000"}),". La llamada a la API devolver\xe1 el struct del root del contrato codificado en SCALE."]}),"\n",(0,n.jsxs)(a.h2,{id:"accediendo-a-elementos-del-storage-con-la-llamada-rpc-childstate",children:["Accediendo a elementos del storage con la llamada RPC ",(0,n.jsx)(a.code,{children:"childState"})]}),"\n",(0,n.jsxs)(a.p,{children:["Por detr\xe1s, cada contrato tiene su propio ",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/substrate/master/frame_support/storage/child/index.html",children:"child trie"}),", donde los elementos del storage son almacenados."]}),"\n",(0,n.jsxs)(a.p,{children:["Adem\xe1s, el pallet ",(0,n.jsx)(a.code,{children:"contracts"})," usa ",(0,n.jsx)(a.a,{href:"https://paritytech.github.io/substrate/master/frame_support/struct.Blake2_128Concat.html",children:(0,n.jsx)(a.code,{children:"Blake2 128 Concat"})})," ",(0,n.jsx)(a.a,{href:"https://docs.substrate.io/build/runtime-storage/#transparent-hashing-algorithms",children:(0,n.jsx)(a.code,{children:"Algoritmo de hashing transparente"})})," para calcular las keys de storage para cada item almacenado dentro del child trie. Deber\xe1 tener eso en cuenta."]}),"\n",(0,n.jsxs)(a.p,{children:["Con eso en mente, para acceder directamente a lo items de storage de cualquier contrato on-chain usando una ",(0,n.jsx)(a.a,{href:"https://polkadot.js.org/apps/#/rpc",children:(0,n.jsx)(a.code,{children:"llamada RPC"})})," childState, necesitar\xe1 lo siguiente:"]}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:["El ID del child trie del contrato, representado como una ",(0,n.jsx)(a.a,{href:"https://docs.rs/sp-storage/10.0.0/sp_storage/struct.PrefixedStorageKey.html",children:(0,n.jsx)(a.code,{children:"PrefixedStorageKey"})})]}),"\n",(0,n.jsx)(a.li,{children:"La key hasheada del campo del storage"}),"\n"]}),"\n",(0,n.jsx)(a.h3,{id:"encontrando-el-id-del-child-trie-de-los-contratos",children:"Encontrando el ID del child trie de los contratos"}),"\n",(0,n.jsxs)(a.p,{children:["El ID del child trie es el hash ",(0,n.jsx)(a.code,{children:"Blake2_256"})," del nonce de instanciaci\xf3n del contrato concatenado a su ",(0,n.jsx)(a.code,{children:"AccountId"}),". Puede encontrarlo en ",(0,n.jsx)(a.a,{href:"https://polkadot.js.org/apps/#/chainstate",children:(0,n.jsx)(a.code,{children:"polkadot-js chainstate query interface"})}),", donde debe ejecutar la query de estado ",(0,n.jsx)(a.code,{children:"contracts_contractInfoOf"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["Tambi\xe9n puede ser calculado manualmente de acuerdo al siguiente snippet de c\xf3digo. El nonce de instanciaci\xf3n del contrato debe ser conocido. Puede obtenerlo usando la query de estado ",(0,n.jsx)(a.code,{children:"contracts_nonce"})," en la UI de polkadot-js."]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-rust",children:'use sp_core::crypto::Ss58Codec;\r\nuse parity_scale_codec::Encode;\r\n\r\n// Dado que nuestro contract ID es 5DjcHxSfjAgCTSF9mp6wQBJWBgj9h8uh57c7TNx1mL5hdQp4\r\nlet account: AccountId32 =\r\n    Ss58Codec::from_string("5DjcHxSfjAgCTSF9mp6wQBJWBgj9h8uh57c7TNx1mL5hdQp4").unwrap();\r\n// Dado que nuestro nonce de instanciaci\xf3n fue 1\r\nlet nonce: u64 = 1;\r\n\r\n// El ID del child trie puede ser calculado as\xed:\r\nlet trie_id = (&account, nonce).using_encoded(Blake2_256::hash);\n'})}),"\n",(0,n.jsxs)(a.h3,{id:"calcular-el-prefixedstoragekey-del-id-del-child-trie",children:["Calcular el ",(0,n.jsx)(a.code,{children:"PrefixedStorageKey"})," del ID del child trie"]}),"\n",(0,n.jsxs)(a.p,{children:["Una ",(0,n.jsx)(a.code,{children:"PrefixedStorageKey"})," basada en el ID del child trie puede ser construida usando la primitiva ",(0,n.jsx)(a.code,{children:"ChildInfo"})," as\xed:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-rust",children:"use sp_core::storage::ChildInfo;\r\nlet prefixed_storage_key = ChildInfo::new_default(&trie_id).into_prefixed_storage_key();\n"})}),"\n",(0,n.jsx)(a.h3,{id:"calcular-la-key-del-storage-usando-hasheo-transparente",children:"Calcular la key del storage usando hasheo transparente"}),"\n",(0,n.jsxs)(a.p,{children:["Finalmente, calculamos la key del storage hasheada del item de storage al que queremos acceder. El algoritmo es simple: Hashear la storage con ",(0,n.jsx)(a.code,{children:"Blake2_128"})," y luego concatenarla con la key sin hashear. Dado que quiera acceder al item de storage correspondiente a ",(0,n.jsx)(a.code,{children:"0x00000000"}),", el c\xf3digo se ver\xe1 as\xed:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-rust",children:"use frame_support::Blake2_128Concat;\r\n\r\n// La key base es 0x00000000\r\nlet storage_key = Blake2_128Concat::hash(&[0, 0, 0, 0]);\n"})}),"\n",(0,n.jsx)(a.h3,{id:"ejemplo-completo",children:"Ejemplo completo"}),"\n",(0,n.jsx)(a.p,{children:"Repasemos los \xfaltimos p\xe1rrafos a trav\xe9s de un ejemplo completo. Dado:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:["Un contrato en la direcci\xf3n ",(0,n.jsx)(a.code,{children:"5DjcHxSfjAgCTSF9mp6wQBJWBgj9h8uh57c7TNx1mL5hdQp4"})]}),"\n",(0,n.jsxs)(a.li,{children:["Con un nonce de instanciaci\xf3n de ",(0,n.jsx)(a.code,{children:"1"})]}),"\n",(0,n.jsxs)(a.li,{children:["La struct del root storage ser\xe1 encontrado en la key base ",(0,n.jsx)(a.code,{children:"0x00000000"})]}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["El siguiente programa Rust demuestra como calcular la ",(0,n.jsx)(a.code,{children:"PrefixedStorageKey"})," del child trie del contrato, as\xed como tambi\xe9n la key hasheada del struct del storage, la cual puede ser usada con la funci\xf3n ",(0,n.jsx)(a.code,{children:"getStorage"})," del endpoint RPC ",(0,n.jsx)(a.code,{children:"childstate"})," en polkadot-js para recibir el struct del storage root del contrato:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-rust",children:'use frame_support::{sp_runtime::AccountId32, Blake2_128Concat, Blake2_256, StorageHasher};\r\nuse parity_scale_codec::Encode;\r\nuse sp_core::{crypto::Ss58Codec, storage::ChildInfo};\r\nuse std::ops::Deref;\r\n\r\nfn main() {\r\n    // Encontrar el ID trie del storage hijo\r\n    let account_id = "5DjcHxSfjAgCTSF9mp6wQBJWBgj9h8uh57c7TNx1mL5hdQp4";\r\n    let account: AccountId32 = Ss58Codec::from_string(account_id).unwrap();\r\n    let instantiation_nonce = 1u64;\r\n    let trie_id = (account, instantiation_nonce).using_encoded(Blake2_256::hash);\r\n    assert_eq!(\r\n        hex::encode(trie_id),\r\n        "2fa252b7f996d28fd5d8b11098c09e56295eaf564299c6974421aa5ed887803b"\r\n    );\r\n\r\n    // Calcular la PrefixedStorageKey basada en el trie ID\r\n    let prefixed_storage_key = ChildInfo::new_default(&trie_id).into_prefixed_storage_key();\r\n    println!("0x{}", hex::encode(prefixed_storage_key.deref()));\r\n    // 0x3a6368696c645f73746f726167653a64656661756c743a2fa252b7f996d28fd5d8b11098c09e56295eaf564299c6974421aa5ed887803b\r\n\r\n    // Calcular la key del storage usando hashing transparente\r\n    let storage_key = Blake2_128Concat::hash(&[0, 0, 0, 0]);\r\n    println!("0x{}", hex::encode(&storage_key));\r\n    // 0x11d2df4e979aa105cf552e9544ebd2b500000000\r\n}\n'})})]})}function u(e={}){const{wrapper:a}={...(0,t.M)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(i,{...e})}):i(e)}},4552:(e,a,r)=>{r.d(a,{I:()=>c,M:()=>o});var n=r(11504);const t={},d=n.createContext(t);function o(e){const a=n.useContext(d);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),n.createElement(d.Provider,{value:a},e.children)}}}]);