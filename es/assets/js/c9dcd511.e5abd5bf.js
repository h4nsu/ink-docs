"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[3540],{76800:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var t=i(17624),a=i(4552);const s={title:"Definiciones Trait",slug:"/basics/definiciones-trait",hide_title:!0},r=void 0,c={id:"basics/trait-definitions",title:"Definiciones Trait",description:"A trav\xe9s del proc. macro #[ink::trait_definition] ahora es posible definir tu propia trait definici\xf3n que se pueden implementar en los ink! smart contracts.",source:"@site/i18n/es/docusaurus-plugin-content-docs/version-5.x/basics/trait-definitions.md",sourceDirName:"basics",slug:"/basics/definiciones-trait",permalink:"/es/5.x/basics/definiciones-trait",draft:!1,unlisted:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-5.x/basics/trait-definitions.md",tags:[],version:"5.x",frontMatter:{title:"Definiciones Trait",slug:"/basics/definiciones-trait",hide_title:!0},sidebar:"reference",previous:{title:"Selectores",permalink:"/es/5.x/basics/selectors"},next:{title:"Gas",permalink:"/es/5.x/basics/gas"}},o={},l=[{value:"Ejemplo",id:"ejemplo",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",p:"p",pre:"pre",...(0,a.M)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("img",{src:"/img/title/text/trait.svg",className:"titlePic"}),"\n",(0,t.jsxs)(n.p,{children:["A trav\xe9s del proc. macro ",(0,t.jsx)(n.code,{children:"#[ink::trait_definition]"})," ahora es posible definir tu propia trait definici\xf3n que se pueden implementar en los ink! smart contracts."]}),"\n",(0,t.jsx)(n.p,{children:"Esto permite definir interfaces de smart contracts compartidas para diferentes implementaciones concretas.\nTenga en cuenta que que esta definici\xf3n trait de ink! puede ser definida en cualquier lugar, incluso en otro crate!"}),"\n",(0,t.jsxs)(n.p,{children:["Vea nuestro ",(0,t.jsx)(n.a,{href:"https://github.com/paritytech/ink-examples/blob/main/trait-erc20/lib.rs",children:(0,t.jsx)(n.code,{children:"ERC20-Trait contracto de ejemplo"})}),"\npara un elaborado ejemplo que utiliza definiciones trait."]}),"\n",(0,t.jsx)(n.h3,{id:"ejemplo",children:"Ejemplo"}),"\n",(0,t.jsxs)(n.p,{children:["Definido en el m\xf3dulo ",(0,t.jsx)(n.code,{children:"base_erc20.rs"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[ink::trait_definition]\npub trait BaseErc20 {\n    /// Crear un nuevo contrato ERC-20 e inicializa con un suministro inicial para el instanciador.\n    #[ink(constructor)]\n    fn new(initial_supply: Balance) -> Self;\n\n    /// Devuelve el suministro total.\n    #[ink(message)]\n    fn total_supply(&self) -> Balance;\n\n    /// Transfiere `amount` de la persona que llama el contrato a `to`.\n    #[ink(message, payable)]\n    fn transfer(&mut self, to: AccountId, amount: Balance);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Una definici\xf3n de un ink! smart contract puede implementar esta definici\xf3n trait as\xed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[ink::contract]\nmod erc20 {\n    use base_erc20::BaseErc20;\n\n    #[ink(storage)]\n    pub struct Erc20 {\n        total_supply: Balance,\n        // m\xe1s campos ...\n    }\n\n    impl BaseErc20 for Erc20 {\n        #[ink(constructor)]\n        fn new(initial_supply: Balance) -> Self {\n            // implementaci\xf3n ...\n        }\n\n        #[ink(message)]\n        fn total_supply(&self) -> Balance {\n            // implementaci\xf3n ...\n        }\n\n        #[ink(message, payable)]\n        fn transfer(&mut self, to: AccountId, amount: Balance) {\n            // implementaci\xf3n ...\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Llamar el ",(0,t.jsx)(n.code,{children:"Erc20"})," de arriba explicitamente mediante su implementaci\xf3n trait se puede haver como un c\xf3digo Rust normal:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// --- Instanciando el contrato ERC-20:\n//\nlet mut erc20 = <Erc20 as BaseErc20>::new(1000);\n// --- Es solo el mismo como:\nuse base_erc20::BaseErc20;\nlet mut erc20 = Erc20::new(1000);\n\n// --- Recuperando el suministro total:\n//\nassert_eq!(<Erc20 as BaseErc20>::total_supply(&erc20), 1000);\n// --- Es simplemente lo mismo como:\nuse base_erc20::BaseErc20;\nassert_eq!(erc20.total_supply(), 1000);\n"})}),"\n",(0,t.jsx)(n.p,{children:"A\xfan existen algunas limitaciones con las ink! trait definiciones y las ink! trait implementaciones.\nPor ejemplo no es posible definir constantes asociadas o tipos o tampoco es posible tener m\xe9todos implementados por defecto.\nEstas limitaciones existen debido a las complejidades t\xe9cnicas, sin embargo muchas de ellas se van a abordar en un futuros lanzamientos de ink!."}),"\n",(0,t.jsx)(n.p,{children:"Marca definiciones trait para ink! como ink! trait definiciones especiales."}),"\n",(0,t.jsxs)(n.p,{children:["Hay algunas restricciones para las definiciones trait de ink! que este macro comprueba. Adem\xe1s las definiciones trait de ink! son necesarias para\ntener una estructura especializada y que la principial macro ",(0,t.jsx)(n.a,{href:"https://docs.rs/ink/4.0.0/ink/attr.contract.html",children:(0,t.jsx)(n.code,{children:"#[ink::contract]"})})," pueda generar correctamente c\xf3digo para su implementaci\xf3n."]}),"\n",(0,t.jsx)(n.h1,{id:"ejemplo-definici\xf3n",children:"Ejemplo: Definici\xf3n"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"type Balance = <ink::env::DefaultEnvironment as ink::env::Environment>::Balance;\n\n#[ink::trait_definition]\npub trait Erc20 {\n    /// Construye un nuevo ERC-20 smart contract utilizando el sumunistro inicial.\n    #[ink(constructor)]\n    fn new(initial_supply: Balance) -> Self;\n\n    /// Devuelve el suministro total del smart contract ERC-20.\n    #[ink(message)]\n    fn total_supply(&self) -> Balance;\n\n    // etc.\n}\n"})}),"\n",(0,t.jsx)(n.h1,{id:"ejemplo-implementaci\xf3n",children:"Ejemplo: Implementaci\xf3n"}),"\n",(0,t.jsx)(n.p,{children:"Con la definici\xf3n trait de arriba puedes implementarla como se muestra a continuaci\xf3n:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[ink::contract]\nmod base_erc20 {\n    /// De alguna manera no podemos poner el trait el el doc-test crate root debido a bugs.\n    #[ink_lang::trait_definition]\n    pub trait Erc20 {\n        /// Construye un nuevo ERC-20 smart contract utilizando el sumunistro inicial.\n        #[ink(constructor)]\n        fn new(initial_supply: Balance) -> Self;\n\n        /// Devuelve el suministro total del smart contract ERC-20.\n        #[ink(message)]\n        fn total_supply(&self) -> Balance;\n    }\n\n    #[ink(storage)]\n    pub struct BaseErc20 {\n        total_supply: Balance,\n        // etc ..\n    }\n\n    impl Erc20 for BaseErc20 {\n        #[ink(constructor)]\n        fn new(initial_supply: Balance) -> Self {\n            Self { total_supply: initial_supply }\n        }\n\n        /// Devuelve el suministro total del smart contract ERC-20.\n        #[ink(message)]\n        fn total_supply(&self) -> Balance {\n            self.total_supply\n        }\n\n        // etc ..\n    }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.M)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},4552:(e,n,i)=>{i.d(n,{I:()=>c,M:()=>r});var t=i(11504);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);