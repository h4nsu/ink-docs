"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[5875],{564:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>n,metadata:()=>i,toc:()=>d});var s=a(17624),t=a(4552);const n={title:"Estructuras de Datos Personalizadas",slug:"/datastructures/custom-datastructure",hide_title:!0},o="Estructuras de Datos Personalizadas",i={id:"datastructures/custom",title:"Estructuras de Datos Personalizadas",description:"El crate ink_storage provee servicios \xfatiles y estructuras de datos para organizar y manipular el storage del contrato. Sin embargo, los autores de contratos deber\xedan saber que ellos pueden crear sus propias estructuras de datos personalizadas.",source:"@site/i18n/es/docusaurus-plugin-content-docs/version-5.x/datastructures/custom.md",sourceDirName:"datastructures",slug:"/datastructures/custom-datastructure",permalink:"/es/5.x/datastructures/custom-datastructure",draft:!1,unlisted:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-5.x/datastructures/custom.md",tags:[],version:"5.x",frontMatter:{title:"Estructuras de Datos Personalizadas",slug:"/datastructures/custom-datastructure",hide_title:!0},sidebar:"reference",previous:{title:"Estructura del storage",permalink:"/es/5.x/datastructures/storage-layout"},next:{title:"Formato de la Metadata",permalink:"/es/5.x/datastructures/storage-in-metadata"}},c={},d=[{value:"Usando tipos personalizados en storage",id:"usando-tipos-personalizados-en-storage",level:2},{value:"Campos de storage gen\xe9ricos",id:"campos-de-storage-gen\xe9ricos",level:2}];function l(e){const r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,t.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("img",{src:"/img/title/storage.svg",className:"titlePic"}),"\n",(0,s.jsx)(r.h1,{id:"estructuras-de-datos-personalizadas",children:"Estructuras de Datos Personalizadas"}),"\n",(0,s.jsxs)(r.p,{children:["El crate ",(0,s.jsx)(r.code,{children:"ink_storage"})," provee servicios \xfatiles y estructuras de datos para organizar y manipular el storage del contrato. Sin embargo, los autores de contratos deber\xedan saber que ellos pueden crear sus propias estructuras de datos personalizadas."]}),"\n",(0,s.jsx)(r.h2,{id:"usando-tipos-personalizados-en-storage",children:"Usando tipos personalizados en storage"}),"\n",(0,s.jsxs)(r.p,{children:["Cualquier tipo personalizado que quiera ser compatible con el  storage de ink! debe implementar el trait ",(0,s.jsx)(r.a,{href:"https://docs.rs/ink_storage_traits/4.0.0/ink_storage_traits/trait.Storable.html",children:(0,s.jsx)(r.code,{children:"Storable"})}),", as\xed puede ser ",(0,s.jsx)(r.a,{href:"https://docs.rs/parity-scale-codec/3.2.2/parity_scale_codec/trait.Encode.html",children:(0,s.jsx)(r.code,{children:"codificado"})})," y ",(0,s.jsx)(r.a,{href:"https://docs.rs/parity-scale-codec/3.2.2/parity_scale_codec/trait.Decode.html",children:(0,s.jsx)(r.code,{children:"decodificado"})})," mediante SCALE. Adem\xe1s, los traits ",(0,s.jsx)(r.a,{href:"https://docs.rs/ink_storage_traits/4.0.0/ink_storage_traits/trait.StorageLayout.html",children:(0,s.jsx)(r.code,{children:"StorageLayout"})})," y ",(0,s.jsx)(r.a,{href:"https://docs.rs/scale-info/2.3.1/scale_info/trait.TypeInfo.html",children:(0,s.jsx)(r.code,{children:"TypeInfo"})})," tambi\xe9n son requeridos. Pero no se preocupe, generalmente estos traits pueden ser derivados:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'/// Un tipo personalizado que podemos usar en nuestro storage del contrato\r\n#[ink::scale_derive(Encode, Decode, TypeInfo)]\r\n#[cfg_attr(\r\n    feature = "std",\r\n    derive(ink::storage::traits::StorageLayout)\r\n)]\r\npub struct Inner {\r\n    value: bool,\r\n}\r\n\r\n#[ink(storage)]\r\npub struct ContractStorage {\r\n    inner: Inner,\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["A\xfan mejor: existe una macro ",(0,s.jsx)(r.a,{href:"https://docs.rs/ink_macro/4.0.0/ink_macro/attr.storage_item.html",children:(0,s.jsx)(r.code,{children:"#[ink::storage_item]"})}),", que deriva todos los traits necesarios. Si no hay necesidad de implementar un comportamiento especial, el c\xf3digo anterior puede ser simplificado de la siguiente manera:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"/// Un tipo personalizado que podemos usar en nuestro storage del contrato\r\n#[ink::storage_item]\r\npub struct Inner {\r\n    value: bool,\r\n}\r\n\r\n#[ink(storage)]\r\npub struct ContractStorage {\r\n    inner: Inner,\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"Naturalmente, uno adem\xe1s puede implementar cualquier caracter\xedstica manualmente. Por favor, consulte directamente la documentaci\xf3n relevante de traits para m\xe1s informaci\xf3n."}),"\n",(0,s.jsxs)(r.admonition,{type:"note",children:[(0,s.jsxs)(r.p,{children:["La macro ",(0,s.jsx)(r.code,{children:"#[ink::storage_item]"})," es responsable del c\xe1lculo de la storage key de los tipos non-",(0,s.jsx)(r.a,{href:"https://docs.rs/ink_storage_traits/4.0.0/ink_storage_traits/trait.Packed.html",children:(0,s.jsx)(r.code,{children:"Packed"})}),". Sin esta, la key para campos non-",(0,s.jsx)(r.code,{children:"Packed"})," ser\xe1 cero. Usar esta macro es necesario si no se planea usar una ",(0,s.jsx)(r.a,{href:"https://docs.rs/ink_storage_traits/4.0.0/ink_storage_traits/struct.ManualKey.html",children:(0,s.jsx)(r.code,{children:"ManualKey"})})," en un tipo non-",(0,s.jsx)(r.code,{children:"Packed"}),"."]}),(0,s.jsxs)(r.p,{children:["Tipos con implementaciones personalizadas de storage de ink! pueden tambi\xe9n usar esta macro solo para c\xe1lculos de key al habilitar los derivados: ",(0,s.jsx)(r.code,{children:"#[ink::storage_item(derive = false)]"}),"."]})]}),"\n",(0,s.jsx)(r.h2,{id:"campos-de-storage-gen\xe9ricos",children:"Campos de storage gen\xe9ricos"}),"\n",(0,s.jsxs)(r.p,{children:["Es posible usar tipos de datos gen\xe9ricos en su storage, siempre y cuando cualquier tipo gen\xe9rico satisfaga los limites requeridos del trait storage. De hecho, ya hemos visto esto en anteriores secciones sobre ",(0,s.jsx)(r.a,{href:"https://docs.rs/ink_storage/4.0.0/ink_storage/struct.Mapping.html",children:(0,s.jsx)(r.code,{children:"Mapping"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Digamos que quiere un mapping que, al acceder a una key no existente, devuelva simplemente su valor predeterminado, similar a como los mappings trabajan en Solidity. Adem\xe1s, debe saber la cantidad de valores que hay en el mapping (la longitud). Esto puede ser implementado como un peque\xf1o wrapper sobre ink! ",(0,s.jsx)(r.a,{href:"https://docs.rs/ink_storage/4.0.0/ink_storage/struct.Mapping.html",children:(0,s.jsx)(r.code,{children:"Mapping"})})," de la siguiente manera:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"/// Los valores para este map deben implementar el trait `Default`.\r\n/// Naturalmente, tambi\xe9n deben ser compatibles con el storage del contrato.\r\n/// Tener en cuenta que el tipo del `Mapping` solo soporta valores `Packed`.\r\n#[ink::storage_item]\r\npub struct DefaultMap<K, V: Packed + Default> {\r\n    values: Mapping<K, V>,\r\n    length: u32,\r\n}\r\n\r\nimpl<K: Encode, V: Packed + Default> DefaultMap<K, V> {\r\n    /// El acceso a keys inexistentes retornar\xe1 el valor predeterminado.\r\n    pub fn get(&self, key: &K) -> V {\r\n        self.values.get(key).unwrap_or_default()\r\n    }\r\n\r\n    /// La inserci\xf3n en el map incrementa la longitud en uno.\r\n    pub fn set<I, U>(&mut self, key: I, value: &U)\r\n    where\r\n        I: scale::EncodeLike<K>,\r\n        E: scale::EncodeLike<V> + Storable,\r\n    {\r\n        if self.values.insert(key, value).is_none() {\r\n            self.length += 1\r\n        }\r\n    }\r\n\r\n    /// La eliminaci\xf3n de un valor del map disminuye la longitud en uno.\r\n    pub fn remove(&mut self, key: &K) {\r\n        if self.values.take(key).is_some() {\r\n            self.length -= 1\r\n        }\r\n    }\r\n\r\n    /// Devuelve la cantidad de valores que contiene el mapping\r\n    pub fn len(&self) -> u32 {\r\n        self.length\r\n    }\r\n}\r\n\r\n/// `DefaultMap` es compatible con el storage del contrato.\r\n#[ink(storage)]\r\npub struct MyContract {\r\n    my_map: DefaultMap<BlockNumber, Balance>,\r\n}\n"})}),"\n",(0,s.jsxs)(r.admonition,{type:"caution",children:[(0,s.jsx)(r.p,{children:"Los tipos de datos gen\xe9ricos pueden incrementar sustancialmente el tama\xf1o del c\xf3digo de su contrato, generando mayores costos para almacenarlo on-chain."}),(0,s.jsxs)(r.p,{children:["La raz\xf3n de esto es la ",(0,s.jsx)(r.a,{href:"https://rustwasm.github.io/twiggy/concepts/generic-functions-and-monomorphization.html",children:'"monomorfizaci\xf3n" de Rust'}),"."]})]})]})}function u(e={}){const{wrapper:r}={...(0,t.M)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},4552:(e,r,a)=>{a.d(r,{I:()=>i,M:()=>o});var s=a(11504);const t={},n=s.createContext(t);function o(e){const r=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(n.Provider,{value:r},e.children)}}}]);